创建和销毁对象
第1条：考虑用静态工厂方法代替构造器
静态工厂方法的几大优势：
1.它们有名称
2.不必在每次调用它的时候都创建一个新的对象
    这使得不可变类可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象
    实例受控使得类可以确保它是一个单例类或者是不可实例话的类
3.它们可以返回原返回类型的任何子类型对象
    服务提供者框架是指这样一个系统：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个实现中解耦出来
    服务提供者框架中有三个重要组件
    服务接口，这是提供者实现的
    提供者注册API，这是系统用来注册实现，让客户端访问它们的
    服务访问API，是客户端用来获取服务的实例的
    第四个可选组件 服务提供者接口，这些提供者负责创建其服务实现的实例。
4.在创建参数化类型实例的时候，它们使代码变得更加简洁
静态工厂方法的几个缺点：
1.类如果不含有公有的或者受保护的构造器，就不能被子类化
2.它们与其他静态方法实际上没有任何区别

静态工厂方法的一些惯用名称：
1.valueOf 该方法返回的实例与它的参数具有相同的值，这样的静态工厂方法实际上是类型转换方法
2.of valueOf的一种更简洁的替代
3.getInstance 返回的实例是通过方法的参数来描述的
4.newInstance 像getInstance一样，但是newInstance能够确保返回的每个实例都与所有其他实例不同
5.getType 
6.newType

(重要)第2条：遇到多个构造器参数时要考虑用构建器
不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器
得到一个builder对象，然后客户端在builder对象上调用类似setter的方法，来设置每个相关的可选参数，最后，客户端调用无参的build方法来生成不可变对象
简而言之，如果类的构造器或者静态工厂中具有多个参数，设计这种类时，构造者模式就是种不错的选择，特别是当大多数参数都是可选的时候
优点是客户端的代码易于阅读和编写，构建器也比javabeans更加安全

第3条：用私有构造器或者枚举类型强化单例属性
实现单例有三种方法
1.公有静态成员是个final域
public class Singleton {
    public static final Singleton INSTANCE = new Singleton();
    private Singleton(){}
}
2.公有的成员是个静态工厂方法
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    private Singleton(){}

    public static Singleton getInstance() {
        return INSTANCE;
    }
}
为了使利用这其中一种方法实现单例类是可序列化的，仅仅在声明上加上实现序列化接口是不够的，为了维护并保证单例，必须每次声明所有实例域都是瞬时的，并提供一个readResolve方法，否则每次反序列化一个序列化的实例时，都会创建一个新的实例
3.使用枚举类型实现单例模式
public enum Singleton{
    INSTANCE;
}
这种方式更加简洁，无偿地提供了序列化机制，绝对防止多次实例化，单元素的枚举类型已经成为实现单例的最佳方法

第4条：通过私有构造器强化不可实例化的能力

第5条：避免创建不必要的对象
一般来说，最好能重用对象而不是每次需要的时候就创建一个相同功能的新对象，如果对象是不可变的，它始终可以被重用。
适配器是这样一个对象，它把功能委托给一个后备对象，从而为后备对象提供一个可以替代的接口，由于适配器除了后备对象之外，没有其他的状态信息，所以针对某个给定对象的特定适配器而言，它不需要创建多个适配器实例。
要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱

第6条：消除过期的对象引用

第7条：避免使用终结方法
终结方法通常是不可预测的，也是很危险的，一般情况下是不必要的

(重要)第8条：覆盖equals时请遵守通用约定
类的每个实例本质上都是唯一的
不关心类是否提供了逻辑相等的测试功能
超类已经覆盖了equals，从超类继承过来的行为对子类也是合适的
类是私有的或是包级私有，可以确定它的equals方法永远不会被调用
覆盖equals方法的时候，必须要遵循它的通用约定：
1.自反性：对于任何非null的引用值x，x.equals(x)必须返回true
2.对称性：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true
3.传递性：对于任何非null的引用值x,y和z。如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true
4.一致性：对于任何非null的引用值x,y只要equals的比较操作在对象所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者返回false。对于任何非null的引用值x,x.equals(null)必须返回false
里氏替换原则：一个类型的任何重要属性也将使用于它的子类型

实现高质量equals方法的诀窍：
1.使用==操作符检查参数是否为这个对应的引用
2.使用instanceof操作符检查参数是否为正确类型
3.把参数转换成正确的类型
4.对于该类中的每个关键域，检查参数中的域是否与该对中对应的域相匹配

对于既不是float也不是double类型的基本类型域，可以使用==操作符进行比较，对于对象引用域，可以递归的调用equals方法，对于float域，可以使用Float.compare方法，对于double域，则使用Double.compare方法
有些对象引用域包含null可能是合法的，所以为了避免导致空指针异常，则使用下面的习惯用法来比较这样的域
    (field == null ? o.field == null :field.equals(o.field))
如果field和o.field通常是相同对象的引用，那么下面的做法就会更快一些
    (field == o.field || (field != null && field.equals(o.field)))
5.当你编写完成了equals方法之后，应该问自己三个问题，它是否是对象的，传递的，一致的
告诫：
覆盖equals时重要覆盖hashCode
不要企图让equals方法过于智能
不要将equals声明中的object对象替换成其他的类型

(重要)第9条：覆盖equals时重要覆盖hashCode
在每个覆盖了equals方法的类中，也必须覆盖hashCode方法
约定：
1.在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次hashCode方法都必须始终如一地返回同一个整数
2.如果两个对象根据equals(object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果
3.如果两个对象根据equals(object)方法比较是不相等的，那么调用这两个对象的任意一个对象的hashCode方法，则不一定产生不同的整数结果

一个好的散列函数通常倾向于为不相等的对象产生不同的散列码
解决办法：
1.把某个非零的常数值，比如说17，保存在一个名为result的int类型的变量中
2.对于对象中的每个关键域f。完成以下步骤
    a.为该域计算int类型的散列码c
        1.如果该域是boolean类型，则计算(f?1:0)
        2.如果该域是byte，char，short或int类型，则计算(int)f
        3.如果该域是long类型，则计算(int)(f^(f>>>32))
        4.如果该域是float类型，则计算Float.floatToIntBits(f)
        5.如果该域是double类型，则计算Double.doubleToLongBits(f),然后按照步骤2.a.3，为得到的long类型的值计算散列值
        6.如果该域是一个对象引用，并且该类的equals方法通过递归的调用equals的方式来比较这个域，则同样为这个域递归调用hashCode
        7.如果该域是一个数组，则要把每一个元素当做单独的域来处理，也就是锁递归的应用上述规则，对每一个重要的元素计算一个散列码，然后根据步骤2.b中的做法，把这些散列值组合起来
    b.按照下面的公式，把步骤2.a中计算得到的散列码c合并到result内
        result = 31*result+c
3.返回result

第10条：始终要覆盖toString
提供好的toString实现可以使类用起来更加舒适
无论你是否决定指定格式，都应该在文档中明确地表明你的意图

第11条：谨慎的覆盖clone

第12条：考虑实现Comparable接口

第13条：使类和成员的可访问性最小化
java程序设计语言提供了许多机制来协助信息隐藏
访问控制机制决定了类，接口和成员的可访问性，实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符共同决定的
第一条规则：尽可能的使每个类或者成员不被外界访问
对于顶层的类和接口，只有两种可能的访问级别，包级私有和公有
如果一个包级私有的顶层类或者接口只是在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的私有嵌套类
四种访问级别
private 只有在声明该成员的顶层类内部才可以访问该成员
default 该成员的包内部的任何类都可以访问这个成员
protected 该成员的类的子类和该成员的包内部的类可以访问这个成员
public 在任何地方都可以访问该成员

如果子类覆盖了超类的方法，子类中的访问级别不允许低于超类中的访问级别
实例域决不能是公有的
包含公有可变域的类并不是线程安全的

第14条：在公有类中使用访问方法而非公有域

第15条：使可变性最小化
为了使类成为不可变，要遵循下面五条规则：
1.不要提供任何会修改对象状态的方法
2.保证类不会被扩展，一般做法是使这个类成为final的
3.使所有的域都是final的
4.使所有的域都成为私有的
5.确保对于任何可变组件的互斥访问
不可变对象比较简单
不可变对象本质上是线程安全的，它们不要求同步
不可变对象可以被自由地共享
不仅可以共享不可变对象，甚至可以共享它们的内部信息
不可变对象为其他对象提供了大量的构件
不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象
让不可变类编程final的另外一个方法就是，让类的所有构造器都变成私有的或者包级私有的，并添加公有的静态工厂来代替公有的构造器

第16条：复合优先于继承
与方法调用不同的是，继承打破了封装性
不用扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称作复合
因为现有的类变成了新类的一个组件，心中类的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果，这种被称为转发，心累中的方法被称为转发方法
它不依赖于现有类的实现细节，即使现有的类添加了新的方法，也不会新的类。
包装类，也正是装饰器模式
只有当子类真正是曹磊的子类型时才适用继承

第17条：要么为继承而设计，并提供文档说明，要么就禁止继承
第18条：接口优于抽象类
抽象类允许包含某些方法的实现，但是接口则不允许，现在好像可以有默认方法了
现在的类可以很容易被更新，以实现新的接口
接口是定义混合类型的理想选择，混合类型是指这样的类型，类除了实现它的基本类型之外，还可以实现这个混合类型，以表明它提供了某些可供选择的行为
接口允许我们构造非层次结构的类型框架

第19条：接口只用于定义类型
常量接口模式是对接口的不良使用，不应该被用来导出常量

第20条：类层次优于标签类
带有两种甚至更多种风格的实例的类，并包含表示实例风格的标签域
标签类过于冗长，容易出错，并且效率低下
标签类正是类层次的一种简单的仿效
为了将标签类转变成类层次，首先要为标签类中的每个方法都定义一个包含抽象方法的抽象类，
接下来，为每种原始标签类都定义根类的具体子类，在每个子类中都包含特定于该类型的数据域，同时在每个子类中包括针对根类中每个抽象方法的相应实现
每个类型的实现都配有自己的类，这些类都没有受到不相关的数据域的拖累，所有的域都是final的，编译器确保每个类的构造器都初始化它的数据域，对于根类中声明的每个抽象方法，都确保有一个实现，这样就杜绝了由于遗漏switch case而导致运行时的失败的可能性
类层次的另一个好处在于，他们可以用来反应类型之间本质上的层次关系，有助于增强灵活性，并进行更好的编译期类型检查
当你想要编写一个包含显示标签域的类时，应该考虑用类层次来代替

第21条：用函数对象表示策略
第22条：优先考虑静态成员类
嵌套类是指被定义在另一个类的内部的类，嵌套类存在的目的应该只是为它的外围类提供服务
嵌套类有四种：静态成员类，非静态成员类，匿名类和局部类，除了第一种之外，其他三种都被称为内部类
非静态成员类的每一个实例都隐含着与外围类的一个外围实例相关联
如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它称为静态成员类，而不是非静态成员类，如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的应用

第23条：请不要在新代码中使用原生态类型
如果使用原生态类型，就死掉了泛型在安全性和表述性方面的所有优势

第24条：消除非首检警告
要尽可能的消费每一个非受检警告

第25条：列表优先于数组
数组是协变的，泛型是不可变的，对于任意两个不同的类型Type1和Type2，List<Type1>既不是List<Type2>的子类型，也不是它的超类型
数组是具体化的，因此数组会在运行时才知道并检查他们的元素类型约束，
泛型这是通过擦除来实现的，因此泛型只在编译时强化他们的类型信息，并在运行时丢弃他们的元素类型信息

第26条：优先考虑泛型
第27条：优先考虑泛型方法

