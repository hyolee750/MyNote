编写线程安全的代码，本质上就是管理对**状态**的访问，而且通常都是 **共享的，可变的状态**

**无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问**

Java中首要的同步机制就是synchronized关键字，它提供了独占锁

术语同步还包括volatile变量，显示锁和原子变量的使用

3种修复同步隐患的方法

1. 不要跨线程共享变量
2. 使状态变量为不可变的，或者
3. 在任何访问状态变量的时候使用同步

无状态的对象永远是线程安全的

volatile变量，它确保对一个变量的更新以可预见的方式告知其他线程，而且对它的操作不会与其他内存操作一起被重排序

读一个volatile类型的变量时，总会返回由某一线程所写入的最新值

#### 垃圾收集

垃圾收集就是自动释放不再被程序所使用的对象的过程

释放不再被引用的对象

##### 垃圾收集算法

任何垃圾收集算法都必须做两件事情，首先，它必须检测出垃圾对象。其次，它 必须回收垃圾对象所使用的堆空间并还给程序

##### 引用计数收集器

不再被使用

##### 跟踪收集器

跟踪收集器追踪从根结点开始的对象引用图，在追踪过程中遇到的对象以某种方式打上标记。当追踪结束时，未被标记的对象就知道是无法触及的，从而可以被收集

基本的追踪算法被称作为 **标记并清除**

### Java虚拟机

**方法区** 存储被装载文件的类型信息，和该类型中的类(静态)变量

所有线程都共享方法区，对方法区数据的访问必须被设计为是线程安全的

类型信息 对每个装载的类型，虚拟机都会在方法区中存储以下类型信息：

- 这个类型的全限定名
- 这个类型的直接超类的全限定名
- 这个类型是类类型还是接口类型
- 这个类型的访问修饰符
- 任何直接超接口的全限定名的有序列表

除了以上列出的基本类型信息外，虚拟机还得为每个被装载的类型存储以下信息：

- 该类型的常量池
- 字段信息
- 方法信息
- 除了常量以外的所有类(静态变量)
- 一个到类ClassLoader的引用
- 一个到Class类的引用

**堆** Java程序在运行时创建的所有类实例或数组都放在同一个堆中

**程序计数器** 每个线程都有它自己的PC寄存器，它是在该线程启动的时候创建的

当线程执行某个Java方法时，PC寄存器的内容总是下一条将被执行的指令的地址

**Java栈** 每当启动一个新线程时，Java虚拟机都会为它分配一个Java栈，

