# Fluent Python

## 第一部分. 序幕

### 1. Python 数据模型

####  一个Python化的卡牌

#### 特殊方法是如何被使用的

##### 仿效数字类型

##### 字符串表述

##### 算数操作符

##### 自定义的布尔值

#### 特殊方法概述

#### 为什么`len`不是一个方法

#### 章节总结

#### 进一步阅读

## 第二部分 数据结构

### 2. 一系列序列

#### 内置序列概述

#### 列表解析和生成表达式

##### 列表解析和可读性

##### 列表解析和`map`,`filter`的对比

##### 笛卡尔产品

##### 生成表达式

#### 元组不仅仅是不可变的列表

##### 元组作为记录

##### 元组解包

##### 嵌套的元组解包

##### 命名的元组

##### 元组作为不可变列表 

#### 切片

##### 为什么切片和范围排除最后一个项目

##### 切片对象

##### 多维切片和省略号

##### 给切片赋值

#### 序列使用`+`和`*`操作符

##### 构建列表的列表

#### 用序列增强赋值

##### A += 赋值 益智

#### `list.sort`和内置的`sorted`函数

#### 使用`bisect`管理有序序列

##### 使用`bisect`搜索

##### 使用`bisect.insort`插入

#### 什么时候列表不是答案

##### 数组

##### 内存视图

##### `NumPy`和`SciPy`

##### 双端队列和其他队列

#### 章节总结

#### 进一步阅读

### 3. 字典和集合

#### 常用的映射类型

#### `dict`解析

#### 常用映射方法概述

##### 使用`setdefault`处理不存在的key

#### 使用灵活的键查询映射

##### `defaultdict`：另一种方式处理不存在的键

##### `__missing__`方法

#### 不同的 `dict`

#### `UserDict`子类

#### 不可变的映射

#### 集合理论

##### `set`文本

##### `set`解析

##### 集合操作

#### `dict`和`set`在引擎罩下

##### 性能测试

##### 字典中的哈希表

##### `dict`工作的实际工作

#### 章节总结

#### 进一步阅读

### 4. 文本VS字节

#### 字符问题

#### 字节基础

##### 结构和内存视图

#### 基本的编码和解码

#### 理解编码和解码问题

##### 

idiomatic 惯用的

使用`collections.namedtuple`构造了一个简单的类来代表单个卡

`namedtuple`通常可以用来构造一个类只有属性而没有自定义方法的对象

使用特殊的方法覆盖Python数据模型的两个好处：

1. 你的类的用户不需要记住任意标准操作的方法名
2. 更容易从丰富的Python标准库获取好处，并避免重复造轮子

#### `__getitem__`的使用

- 当对象进行`[]`操作时，内部调用对象的`__getitem__`方法
- 实现了`__getitem__`特殊方法后，我们的对象也是可以迭代的

#### 特殊方法是如何使用的

1. 特殊方法由Python解释器调用，而不是你
2. 对于内置类型，如`list`,`str`,`bytearray`采取了继续捷径，要比调用方法块的多
3. 特殊方法的调用是隐式的，例如`for i in x:`实际上是调用了`iter(x)`方法，最终变成调用`x.__iter__()`方法
4. 一般来说，你的代码不应该由太多的直接调用特殊方法的方法
5. 如果你需要调用一个特殊的方法，通常最好调用内置的函数，这些内置函数会调用相应的特殊方法
6. 避免创建任意自定义属性使用`__foo__`语法，因为这样的名称可能在未来有特殊的意义

#### 字符串表述

`__repr__`特殊方法被`repr`内置指令调用，来获取一个对象的字符串表述。如果我们没有实现该方法，对象实例将会在控制台显示类似下面的字符串`<Vector object at 0x10e100070>`

和`__repr__`相比还有一个叫`__str__`，被`str()`构造器调用，同时，也会被`print`函数隐式地调用

如果你只实现这些特殊方法的其中一个，选择`__repr__`,因为当没有自定义的`__str__`可用的时候，Python将会调用`__repr__`方法

`__add__`对应操作符`+`

`__mul__`对应操作符`*`

默认情况下，用户定义的类的实例被认为是True，除非定义了`__bool__`方法或`__len__`方法

**列表解析和元组拆包**

```python
tshirts = [(color,size) for color in colors for size in sizes]
```

```python
city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8015)
```



