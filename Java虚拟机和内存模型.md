### 运行时数据区域

我们看一下Java虚拟机运行时数据区域

![Java虚拟机运行时数据区域](../images/neicunmoxing.png)

### 程序计数器

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，每个线程都有自己的独立的程序计数器。
<br/>
如果线程正在执行的是java方法，那么这个计数器就是正在执行虚拟机字节码指令的地址，如果正在执行的是本地方法，这个计数器值为空(undefined)。

### Java虚拟机栈

线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧用于存储<font color='red'>**局部变量表**</font>、<font color='red'>**操作数栈**</font>、<font color='red'>**动态链接**</font>、<font color='red'>**方法出口**</font>等信息。

局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型（指向了一条字节码指令的地址）。

其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余的数据类型占1个。局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
如果线程请求栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；无法申请到内存抛出OutOfMemoryError异常。

### 本地方法栈

本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地栈则为虚拟机使用到的Native方法服务。

### Java堆

Java堆是线程共享的，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。

在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。

### 方法区(永久代)

线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
这区域的内存回收目标主要是针对常量池的回收和对类型的卸载！

### 运行时常量池

他是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是<u>常量池，用于存放编译期生成的各种字面量和符号引用</u>，这部分内容将在类加载后进入方法区的运行时常量池中存放。

### 直接内存

直接内存不是虚拟机运行时数据区的一部分。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。