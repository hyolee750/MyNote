这个要比sublime text要好多了，至少支持中文，同时也更轻量级，可以作为我日常开发，做笔记的东西了
加油
自己要学习的东西还有很多，不能放弃，只能继续的孤独前行
java自动转换
自动转换的条件
    这两种类型是兼容的
    目的类型的范围比来源类型的大
强制转换
    两种类型兼容
    目的类型的范围比来源类型的小
类型提升的约定
    byte和short类型的值会被提升到int型
    如果一个操作数是long型，整个表达式将被提升到long型
    如果一个操作数是float。整个表达式将被提升到float型
    如果有一个操作数是double，整个表达式将被提升到double型
    
位运算符
    ～ 按位非 NOT
    & 按位与 AND
    | 按位或 OR
    ^ 按位异或 XOR
    >> 右移
    >>> 右移 左边空出的位以0填充
    << 左移
    &= 按位与赋值
    
Java运算符的优先级
最高
()  []  .
++  --  ~   !
*   /   %
+   -   
>>  >>> <<
>   >=  <   <=
==  !=
&
^
|
&&
||
?:
=   op=
最低

switch语句的注意点
    break语句是可选的，如果你省略了break语句，程序将继续执行下一个case语句，有时需要在多个case语句之间没有break语句
    
this关键字
    this总是调用该方法对象的一个引用
    你可以在当前类的类型所允许的对象的任何地方将this作为一个引用
隐藏的实例变量
    局部变量包括传递到方法的正式自变量，可以与类的实例变量的名称重叠，在这种情况下，局部变量就隐藏了实例变量名
    
值传递和引用传递
    在java中，当你给一个方法传递一个简单类型时，它是按照值传递的
    当你给一个方法传递一个对象时，因为对象是通过引用传递的，这样会影响作为参数的对象
    
访问控制符的作用范围 
    这个不用讲了，已经会了

理解static
    声明为static方法的限制
    1.它们仅能调用其他的static方法
    2.它们只能访问static数据
    3.它们不能以任何方式引用this和super
    静态代码快仅在该类被加载时执行一次
    
等下回头还是要去看数据结构和算法的
要做到知其然知其所以然


继承
一个超类变量可以指向一个子类对象
重要：
引用变量的类型，而不是它指向的对象的类型，决定了可以访问的成员
也就是说 如果引用变量是父类，那么只能访问父类的成员，如果引用变量是子类，既可以访问父类也可以访问子类的成员
因为超类并不知道自己的子类是什么

每当一个子类需要指向它的直接父类，可以使用关键字super
super关键字有两种形式：
    1.调用父类的构造器
    当一个子类调用super()，它会调用它的直接父类的构造器，
    super()方法总是指向父类
    super() 必须在子类构造器的第一行
    2.访问父类中被子类成员隐藏的成员
        如果子类中有和父类同名的变量和方法，那么子类就会将父类的同名的方法或变量隐藏

构造器执行的顺序
    按照父类-子类的执行顺序 
    
方法覆盖
    只有当父类和子类的方法具有相同的名称和相同的签名类型
    
动态方法匹配
    调用一个覆盖的方法在运行时解析而不是在编译期
    一个超类的引用变量可以指向一个子类对象 java使用这个事实在运行时来解析覆盖方法的调用
    是被指向的对象的类型而不是引用变量的类型 决定哪个版本的覆盖方法执行

总结： 
    对于变量，以引用变量的类型为准
    比如 父类 f = new 子类
    那么 不管子类是谁， 调用f.variable 都是直接调用该引用变量类型的成员
    对于覆盖的方法，注意是覆盖，而不是其他方法，
    该方法的调用是根据被指向对象的类型来决定的，如果右边是子类，那么就调用子类覆盖的方法
    父类只能访问子类覆盖的方法，而不能访问其他方法
    
动态 运行时多态

使用抽象类

任何类包含一个或多个抽象方法也必须被声明抽象的
声明一个抽象类，使用abstract关键字
一个抽象类不能直接使用new实例化
不能声明抽象的构造器和抽象的静态方法
一个抽象的子类必须实现其父类所有的抽象方法或者自己也是抽象的

final关键字的三个作用
1.创建等价的命名常量
2.使用final阻止覆盖 声明为final的方法不能被覆盖
3.使用final阻止继承

不能同时使用abstract和final来修饰一个类

一个类可以实现多个接口但是只能继承一个父类

包 

public 对所有类都可见
private 只对本类可见
default 对本类和本包可见
protected 对本类本包 和其子类可见

package
import

interface
一个接口的引用变量只知道被接口声明的方法
不能访问具体实现类的字段和特有的方法

部分实现
必须要用abstract修饰

注解的限制
一个注解不能继承其他注解
一个注解声明的方法永远不能有参数，并且他们必须返回以下类型
    1.基本类型，像int double
    2.一个String 或者class对象
    3.一个enum类型
    4.另一个注解类型
    5.之前类型的数组
注解不能是泛型的，换句话说，他们不能有类型参数
注解不能产生throw 原因


泛型 意味着参数化类型
泛型增加了类型安全

class Gen<T> {}
T 类型参数的名称，是实际参数的容器
泛型只能使用于引用类型，而不能是基本类型
泛型类型不同，基于它们的类型参数
泛型是如何改善类型安全的

类型边界
<T extends superclass>
T只能被替换成superclass或者其子类
参数类型不能被实例化
静态成员不能使用类型参数
你不能创建泛型的数组
一个泛型类不能继承Throwable，也就是不能创建泛型异常类



