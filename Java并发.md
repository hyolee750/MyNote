## 1. 线程管理

#### 创建和运行线程

创建线程的两种方式：

1. 继承`Thread` 类，覆盖`run()` 方法
2. 实现`Runnable` 接口

每个java程序至少有一个执行线程，当你运行程序时，JVM执行main方法的执行线程

当我们调用一个线程对象的`start()` 方法时，我们在创建另一个执行线程，调用了多少次`start()` 方法就会有多少个执行线程

当所有的非守护线程结束时，程序结束了，如果初始线程结束了，其余的线程将会继续执行直到它们完成，如果一个线程使用了`System.exit()` 方法结束程序的执行，那么所有的线程都会结束它们的执行

创建一个`Thread` 类的对象不会创建新的执行线程，同样，调用一个实现了`Runnable` 接口的类的`run()`方法也不会创建新的执行线程，只有调用`start()` 方法才会创建新的执行线程

#### 获取和设置线程信息

1.  ID： 该属性存储了每个线程的唯一标识符
2.  Name： 该属性存储了线程的名称
3.  Priority： 该属性存储了线程对象的优先级，线程的优先级从1-10，1是最低的优先级，10是最高的优先级，不推荐改变线程的优先级
4.  Status： 该属性存储了线程的状态，在java，线程可以是6种状态的其中之一： new，runnable，blocked，waiting，time waiting，terminated

#### 中断线程

java提供了中断机制来表明一个线程我们想要结束它，这种机制的一个特点就是线程必须检查它是否已经被中断了，并且它可以决定它是否响应于完成请求，线程可以忽略它并继续执行

`Thread` 类有一个属性存储了布尔值表明线程是否被中断，当你调用一个线程的`interrupt()` 方法，你设置该值为true。`isInterrupted()` 方法仅仅返回该属性的值

`Thread` 类还有另外一个方法用来检查线程是否被中断，这就是静态方法`interrupted()` ，用来检查是否当前正在执行的线程是否已经被中断

#### 控制线程的中断

使用java异常来控制线程的中断

#### 睡眠和挂起线程

使用`Thread.sleep(n)` 方法来使线程睡眠，挂起

#### 等待线程最终确定

使用`join()` 方法，当调用该方法时，它会挂起当前调用线程的执行，直到被调用的对象完成它的执行

记住，调用哪个线程的join方法，就会引起该线程立即执行，而当前线程挂起，直到被调用的线程完成执行

java提供了额外两种形式的join方法

1. `join(long milliseconds)`
2. `join(long milliseconds,long nanos)`

第一个版本的join方法，等待具体的毫秒值之后执行

#### 创建和运行守护线程

使用Thread类的`setDaemon(true);` 设置线程为守护线程

使用`isDaemon()` 方法检查一个线程是否是守护线程

#### 处理线程未控制的异常

使用`thread.setUncaughtExceptionHandler(eh)`方法设置未捕获异常处理器

当一个线程抛出一个异常，没有被捕获(该异常必须是非检查型异常)，JVM检查是否线程有一个未捕获异常处理器，如果有，JVM调用该异常处理器的方法，如果线程没有设置异常处理器，JVM打印堆栈信息到控制台，然后退出程序

静态方法`setDefaultUncaughtExceptionHandler()` 建立一个异常处理器为该应用的所有线程对象

当线程抛出一个未捕获异常，JVM为该异常寻找3种可能的处理器

首先，它寻找线程的未捕获异常处理器，如果不存在

其次，它寻找该线程的线程组的未捕获异常处理器，如果不存在

再次，它寻找默认的未捕获异常处理器，如果还不存在

最后，打印堆栈信息到控制台

#### 使用本地线程变量

使用`ThreadLocal`来存储本地线程变量

使用`get()` 方法读取该值

使用`set()` 方法设置该值

如果没有值，调用`initialValue()` 初始化一个值

使用`remove()` 方法删除该值

#### 线程组

`ThreadGroup` 对象的使用

#### 处理线程组的未控制的异常

覆盖`ThreadGroup` 的`public void uncaughtException(Thread t, Throwable e)` 方法，设置自定义处理

#### 通过工厂创建线程

`ThreadFactory` 的接口的应用

## 2.基本线程同步

核心部分：是一个代码块访问一个共享资源并且在同一时刻不能被多个线程执行

同步机制：

#### 同步方法

使用`synchronized` 关键字来控制并发访问方法

静态方法有不同的行为，只有一个执行线程可以访问一个声明了`synchronized` 关键字的静态方法，但是另一个线程可以访问该对象的其他非静态方法，你必须要小心处理这一点

#### 在同步类中排列独立属性

使用对象作为锁 `private final Object lock = new Object()`

#### 在同步代码中使用条件

处理**生产者-消费者** 模式产生的问题，使用`wait()` ,`notify()` ,`notifyAll()` 方法来实现

#### 使用Lock同步代码块

Lock接口和它的实现ReentrantLock，该机制的优点：

1. 允许更灵活的组织同步代码块
2. 比`synchronized` 关键字提供了额外的功能，比如tryLock()方法
3. Lock接口允许分开读和写操作，有多个读者和只有一个修改的
4. Lock接口提供了更好的性能

```java
public void printJob(Object document) {
        queueLock.lock();
        try {
            Long duration = (long) (Math.random() * 10000);
            System.out.println(Thread.currentThread().getName() + ":PrintQueue: Printing a Job during " + (duration / 1000) + " seconds");
            Thread.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            queueLock.unlock();
        }
    }
```

#### 使用读写锁同步数据访问

`ReadWriteLock` 接口和`ReentrantReadWriteLock` 实现类

该类有两个锁，一个用来进行读操作，另一个用来进行写操作

多个线程可以使用读操作，但是只有一个线程可以使用写操作

当一个线程正在进行写操作时，任何线程都不能进行读操作

#### 修改Lock公平

ReentrantLock和ReentrantReadWriteLock的构造器接收一个布尔参数，它允许控制类的行为，false值是默认值，叫不公平模式，在这个模式中，无条件选择等待的线程，true为公平模式，它会选择等待时间最长的线程

#### 在一个Lock中使用多个条件

Condition接口提供了机制来挂起一个线程和唤醒一个被挂起的线程

## 3. 线程同步工具集

在第2章，基本线程同步，教会我们下面基础的同步机制：

1. `synchronized` 关键字
2. Lock接口和它的实现类，`ReentrantLock` ，`ReentrantReadWriteLock.ReadLock` ，`ReentrantReadWriteLock.WriteLock` 

这一章，我们将会学习如何使用高水平机制来获取多线程的同步，这些高水平的机制如下所示：

1. **Semaphores** ：信号是一个计数器，用来控制访问一个或多个共享资源，该机制是并发编程的基础工具之一，绝大多数编程语言都有支持
2. **CountDownLatch** ： 倒数锁存器，由java语言实现，允许一个线程等待多个操作的终止
3. **CyclicBarrier** ： 环状屏障，该类是java语言提供的另外一个机制，允许多个线程在一个普通点同步
4. **Phaser** ： 阶段，该类是java语言提供的另外一个机制，控制并发任务划分成阶段执行，所有的线程必须完成一个阶段在它们能继续下一个的阶段的时候
5. **Exchanger** ： 交换器，提供了在两个线程之间数据交换的点

#### 控制资源的并发访问

一个信号是一个计数器来保护访问一个或多个共享资源

当一个线程想要访问这些共享资源之一的时候，首先，它必须获取信号，如果信号内部的计数器大于0，信号减少计数器，允许访问共享资源，计数器大于0意味着有免费的资源可以使用，所以线程可以访问其中之一

如果，信号的计数器是0，信号使线程睡眠直到计数器大于0，计数器为0意味着所有共享资源都已被其他线程使用，所以该线程想要使用其中之一必须等到一个资源被释放

当某线程已经完成共享资源的使用，它必须释放信号，以便其他信号可以访问共享资源，这个操作增加信号内部计数器的值

记住：一切用于同步的方法，都和共享资源有关，当有操作共享资源的方法，必须要使用同步来进行保护 ，防止多线程并发访问

信号的使用方法：

1.  使用`semaphore.acquire();` 方法获取信号，如果信号内计数器大于0，就可以获取到访问的权限，如果等于0，则需要等待，直到有一个线程释放了资源
2. 处理资源
3. 使用`semaphore.release();` 方法释放信号，该操作会导致信号内计数器增加

`Semaphore` 类有两个额外版本的`acquire()` 方法：

1. `acquireUninterruptibly()` `acquire()` 方法的原理：当信号内部计数器等于0，阻塞线程，知道信号被释放，在阻塞期间，线程可能被中断，该方法会抛出一个中断异常，该版本的请求操作将会忽略该该线程的中断，不会抛出任何异常
2.  `tryAcquire()` 该方法试图获取信号，如果可以，该方法返回true，如果不可以，该方法返回false，不会被阻塞和等待信号的释放，基于返回的值，可以决定采用正确的行为

信号的公平模式

和之前的机制类型，设置为公平模式，会选择等待时间最长的线程

#### 控制并发访问一个资源的多个复制

使用二进制信号，这种类型的信号被用来保护访问一个共享的资源或者同一时间只能被一个线程执行的核心部分，但是信号也可以用来保护一个资源的多个复制，或者同一时间可以被多个线程执行的核心部分

