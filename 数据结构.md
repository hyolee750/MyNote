这次一定要坚持到底的将数据结构的学习进行下去，不能半途而废，同时也要温故知新，不断的提高自身的知识水平

新的一年，希望能完成的几个小目标之一

1. 熟练掌握各种数据结构，比如线性表，栈，队列，串，数组，广义表，树，图等结构的实现原理，思想，优点，缺点等
2. 熟练掌握各种算法，算法和数据结构才是程序，只有把这两项掌握好了，可以胜任任何语言的工作
3. 开始大数据入门，随着最近互联网的大热，大数据越来越重要，这也是我今后将要研究的课题

那么，就从数据结构开始吧，我希望自己不仅仅是记下来一些要点就不看了，一定要经常看看自己的笔记，从自己总结的经验中得到思考，并加深自己的印象，让知识存在脑海中，而不是笔记本上

### 线性表

#### 线性表的逻辑结构

线性表是由n个类型相同的数据元素组成的有限序列

线性表的数据元素之间具有一定的顺序

除了第一个元素外，每个元素有且仅有一个直接前驱元素

除了最后一个元素外，每个元素有且只有一个直接后继元素

#### 基本操作集合

1. InitList() 初始化操作，构造一个空的线性表
2. isEmpty() 判断线性表是否为空，是返回true，否返回false
3. get(int index) 根据索引获取线性表中的元素
4. indexOf(E e) 获取元素在线性表中的位置
5. add(E e) 插入元素
6. remove(E e) 删除元素
7. length() 返回线性表的长度
8. clear() 清空线性表

#### 线性表的顺序表示和实现

线性表的顺序存储是指将线性表中的元素存放在一组连续的存储单元中，这样的存储方式使得线性表逻辑上相邻的元素，其在物理存储单元也是相邻的

线性表的顺序存储结构是一种随机存储的存储结构

数组具有随机存取数组中的元素占用连续的存储空间，因此，采用数组描述线性表的顺序存储结构

#### 顺序表的实现算法分析

除了按内容查找运算，插入和删除操作外，算法的时间复杂度都为O(1)。

在按内容查找算法中，查找元素需要比较的平均次数为(n+1)/2，所以平均时间复杂度为O(n)。

在插入算法中，时间的耗费主要集中在移动元素上，在顺序表中插入操作需要移动元素的平均次数为n/2，所以插入操作的平均时间复杂度为O(n)。

在删除算法中，时间耗费同样在移动元素上，删除操作需要移动元素的平均次数为(n-1)/2，所以删除操作的平均时间复杂度为O(n)。

#### 顺序表的应用举例

应用1： 如果在顺序表A中出现的元素，在顺序表B中也出现，则将顺序表A中的该元素删除

分析实现思路：

> 1. 依次把B中的每个元素取出给e
> 2. 在A中查找和B中取出的元素e相等的元素
> 3. 如果找到该元素，将其从A中删除

```java
public static void deleteElement(int[] a, int[] b) {
  int r = 0, w = 0;
  int size = a.length;
  try {
    for (; r < size; r++)
      if (!contains(b, a[r]))
        a[w++] = a[r];
  } finally {
    if (w != size) 
      for (int i = w; i < size; i++)
        a[i] = 0;
  }
}
```

应用2： 顺序表A和顺序表B的元素是非递减排列，利用线性表的基本运算，将它们合并成一个顺序表C，要求顺序表C也是非递减排列。

分析实现思路：

> 1. 取出顺序表A和B中的元素，并将这两个元素进行比较
> 2. 如果A中的元素m1大于B中的元素n1，则将B中的元素n1插入到C中，继续取出B中下一个元素n2与A中的元素m1比较
> 3. 如果A中的元素m1小于B中的元素n1，则将A中的元素m1插入到C中，继续取出A中下一个元素m2与B中元素n1比较，依次类推，直到一个表中的元素比较完毕
> 4. 将另外一个表中剩余元素插入到C中

代码实现：

```java
private int[] merge(int[] a, int[] b) {
  int[] c = new int[a.length + b.length];
  int i = 0, j = 0, k = 0;
  while (i < a.length && j < b.length) {
    if (a[i] <= b[j]) c[k++] = a[i++];
    else c[k++] = b[j++];
  }
  while (i < a.length) c[k++] = a[i++];
  while (j < b.length) c[k++] = b[j++];
  return c;
}
```

#### 线性表的链式表示与实现

在顺序表中，由于逻辑上相邻的元素其物理位置也相邻，因此可以随机存储顺序表中的任何一个元素。但是顺序表也存在着缺点，插入和删除运算需要移动大量的元素，存储分配必须事先进行分配，事先分配的存储单元的大小可能不适合问题的需要

#### 单链表的存储结构

线性表的链式存储是采用一组任意的存储单元存放线性表的元素，可以连续也可以不连续

以结点作为存储结构

结点包含两个域：数据域和指针域，其中数据域存放数据元素的信息，指针域存放元素的直接后继的存储地址





