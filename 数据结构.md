这次一定要坚持到底的将数据结构的学习进行下去，不能半途而废，同时也要温故知新，不断的提高自身的知识水平

新的一年，希望能完成的几个小目标之一

1. 熟练掌握各种数据结构，比如线性表，栈，队列，串，数组，广义表，树，图等结构的实现原理，思想，优点，缺点等
2. 熟练掌握各种算法，算法和数据结构才是程序，只有把这两项掌握好了，可以胜任任何语言的工作
3. 开始大数据入门，随着最近互联网的大热，大数据越来越重要，这也是我今后将要研究的课题

那么，就从数据结构开始吧，我希望自己不仅仅是记下来一些要点就不看了，一定要经常看看自己的笔记，从自己总结的经验中得到思考，并加深自己的印象，让知识存在脑海中，而不是笔记本上

### 线性表

#### 线性表的逻辑结构

线性表是由n个类型相同的数据元素组成的有限序列

线性表的数据元素之间具有一定的顺序

除了第一个元素外，每个元素有且仅有一个直接前驱元素

除了最后一个元素外，每个元素有且只有一个直接后继元素

#### 基本操作集合

1. InitList() 初始化操作，构造一个空的线性表
2. isEmpty() 判断线性表是否为空，是返回true，否返回false
3. get(int index) 根据索引获取线性表中的元素
4. indexOf(E e) 获取元素在线性表中的位置
5. add(E e) 插入元素
6. remove(E e) 删除元素
7. length() 返回线性表的长度
8. clear() 清空线性表

#### 线性表的顺序表示和实现

线性表的顺序存储是指将线性表中的元素存放在一组连续的存储单元中，这样的存储方式使得线性表逻辑上相邻的元素，其在物理存储单元也是相邻的

线性表的顺序存储结构是一种随机存储的存储结构

数组具有随机存取数组中的元素占用连续的存储空间，因此，采用数组描述线性表的顺序存储结构

#### 顺序表的实现算法分析

除了按内容查找运算，插入和删除操作外，算法的时间复杂度都为O(1)。

在按内容查找算法中，查找元素需要比较的平均次数为(n+1)/2，所以平均时间复杂度为O(n)。

在插入算法中，时间的耗费主要集中在移动元素上，在顺序表中插入操作需要移动元素的平均次数为n/2，所以插入操作的平均时间复杂度为O(n)。

在删除算法中，时间耗费同样在移动元素上，删除操作需要移动元素的平均次数为(n-1)/2，所以删除操作的平均时间复杂度为O(n)。

#### 顺序表的应用举例

应用1： 如果在顺序表A中出现的元素，在顺序表B中也出现，则将顺序表A中的该元素删除

分析实现思路：

> 1. 依次把B中的每个元素取出给e
> 2. 在A中查找和B中取出的元素e相等的元素
> 3. 如果找到该元素，将其从A中删除

```java
public static void deleteElement(int[] a, int[] b) {
  int r = 0, w = 0;
  int size = a.length;
  try {
    for (; r < size; r++)
      if (!contains(b, a[r]))
        a[w++] = a[r];
  } finally {
    if (w != size) 
      for (int i = w; i < size; i++)
        a[i] = 0;
  }
}
```

应用2： 顺序表A和顺序表B的元素是非递减排列，利用线性表的基本运算，将它们合并成一个顺序表C，要求顺序表C也是非递减排列。

分析实现思路：

> 1. 取出顺序表A和B中的元素，并将这两个元素进行比较
> 2. 如果A中的元素m1大于B中的元素n1，则将B中的元素n1插入到C中，继续取出B中下一个元素n2与A中的元素m1比较
> 3. 如果A中的元素m1小于B中的元素n1，则将A中的元素m1插入到C中，继续取出A中下一个元素m2与B中元素n1比较，依次类推，直到一个表中的元素比较完毕
> 4. 将另外一个表中剩余元素插入到C中

代码实现：

```java
private int[] merge(int[] a, int[] b) {
  int[] c = new int[a.length + b.length];
  int i = 0, j = 0, k = 0;
  while (i < a.length && j < b.length) {
    if (a[i] <= b[j]) c[k++] = a[i++];
    else c[k++] = b[j++];
  }
  while (i < a.length) c[k++] = a[i++];
  while (j < b.length) c[k++] = b[j++];
  return c;
}
```

#### 线性表的链式表示与实现

在顺序表中，由于逻辑上相邻的元素其物理位置也相邻，因此可以随机存储顺序表中的任何一个元素。但是顺序表也存在着缺点，插入和删除运算需要移动大量的元素，存储分配必须事先进行分配，事先分配的存储单元的大小可能不适合问题的需要

#### 单链表的存储结构

线性表的链式存储是采用一组任意的存储单元存放线性表的元素，可以连续也可以不连续

以结点作为存储结构

结点包含两个域：数据域和指针域，其中数据域存放数据元素的信息，指针域存放元素的直接后继的存储地址

#### 循环单链表

循环单链表是一种首尾相连的单链表，它是在单链表的基础上，将单链表的最后一个节点的指针域由NULL变成指向单链表的头结点或第一个结点

循环单链表也有带头结点结构和不带头结点结构两种

循环单链表不为空时，最后一个结点的指针域指向头结点，循环单链表为空时，头结点指针域指向头结点本身

判断链表是否为空的条件 head->next == head

将两个设置尾指针的循环单链表合并只需要三步ckz操作：

1. LA->next = LB->next->next，将LA的表尾与LB的第一个结点相连
2. free(LB->next)，释放LB的头结点
3. LB->next = LA->next，将LB的表尾与LA的表头相连

约瑟夫问题。有n个人，编号为1,2,3,...,n，围成一个圆圈，按照顺时针方向从编号为k的人从1开始报数，报数为m的人出列，他的下一个人重新开始从1报数，数到m的人出列，如此重复下去，直到所有人都出列，编写一个算法，要求输入n，k，m，按照出列的顺序输出编号

分析：

1. 建立一个具有n个结点的不带头结点的循环单链表，编号从1到n，代表n个人
2. 找到第k个结点，即第一个开始报数的人
3. 编号为k的人从1开始报数，并开始计数，报到m的人出列，即将该结点删除

#### 双向链表

双向链表是指链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点

##### 双向链表的存储结构

在双向链表中，每个结点包括三个域，data域，prior域和next域

data域为数据域，用来存放数据元素

##### 双向链表的插入操作和删除操作

插入操作:

算法思想：首先找到第i个结点，用p指向该结点，再申请一个新结点，由s指向该结点，将e放入到数据域中。然后开始修改p和s指向的结点的指针域：修改s的prior域，使其指向p的直接前驱结点，即s->prior = p->prior，修改p的直接前驱结点的next域，使其指向s所指向的结点，即p->prior->next = s，修改s的next域，使其指向p指向的结点，即s->next = p，修改p的prior域，使其指向s指向的结点，即p->prior = s

1. s->prior = p->prior
2. p->prior->next = s
3. s->next = p
4. p->prior = s

删除操作：

1. 修改p的前驱结点的next域，使其指向p的直接后继结点，p->prior->next=p->next
2. 修改p的直接后继结点的prior域，使其指向p的直接前驱结点，即p->next->prior=p->prior

插入和删除操作的时间复杂度都为O(1)

---

2017年2月3日 星期五

第一天上班，努力工作，好好学习，这个星期争取把树的知识和一些经典的算法学会，下个星期学习图，这次不再从前面开始学了，从后面开始学习

### 第9章 树

本章的主要学习内容包括树的定义，二叉树的定义与特质，二叉树的存储表示与实现，二叉树的遍历，二叉树的线索化，树与森林的转换及哈夫曼树

#### 9.1 树的定义及抽象数据类型

##### 9.1.1 树的定义

树是n(n>=0)个结点的有限序列，其中，n=0时，称为空树。当n>0时，称为非空树，满足以下条件：

1. 有且只有一个称为根的结点
2. 当n>1时，其余n-1个结点可以划分为m个有限集合，且这m个有限集合不相交，其中的一个T又是一棵树，称为根的子树。

树是一个递归的定义

下面介绍关于树的一些基本概念

**树的结点：** 包含一个数据元素及若干指向子树分支的信息

**结点的度：** 一个结点拥有子树的个数称为结点的度

**叶子结点：** 没有子树的结点也就是度为0的结点称为叶子结点

**分支结点：** 也称为非终端结点，度不为零的结点称为非终端结点

**孩子结点：** 一个结点的子树的根结点称为孩子结点

**双亲结点：** 也称父结点，如果一个结点存在孩子结点，则该结点就称为孩子结点的双亲结点

**子孙结点：** 在一个根结点的子树的任何一个结点都称为该根结点的子孙结点

**树的度：** 树中所有结点的度的最大值

**树的层次：** 从根结点开始，根结点位于第一层，根结点的孩子结点位于第二层，以此类推。

**树的深度：** 也称为树的高度，树中所有结点的层次最大值称为树的深度

#### 9.2 二叉树

##### 9.2.1 二叉树的定义

二叉树中的每个结点最多只有两棵子树

二叉树中的每个结点都有左右次序之分，次序不能颠倒

二叉树中的每个结点的度只可能是0,1,2

位于左边的孩子结点称为左孩子

位于右边的孩子结点称为右孩子

如果n=0，则称该二叉树为空二叉树

**满二叉树：** 每层结点都是满的二叉树

**完全二叉树：** 如果一颗二叉树有n个结点，并且二叉树的n个结点的结构与满二叉树的前n个结点的结构完全相同，这样的二叉树为完全二叉树

##### 9.2.2 二叉树的性质

**性质1：在二叉树中，第m层(m>=1)上至多有2^(m-1)个结点**

**性质2：深度为k(k>=1)的二叉树至多有2^k -1个结点**

**性质3：对任何一棵二叉树T，如果叶子结点总数为n0，度为2的结点总数为n2，则有n0=n2+1**

**性质4：如果完全二叉树有n个结点 ，则深度为log2(n)+1** 

#### 9.3 二叉树的存储表示与实现

##### 9.3.1 二叉树的顺序存储

完全二叉树的存储可以按照从上到下，从左到右的顺序依次存储在一维数组中

##### 9.3.2 二叉树的链式存储

二叉树的链式存储结构包含三个域：**数据域，左孩子指针域和右孩子指针域** ，其中，数据域存储该结点的值，左孩子指针域指向左孩子结点，右孩子指针域指向右孩子结点

#### 9.4 二叉树的遍历

##### 9.4.1 二叉树的先序遍历

如果二叉树为空，则执行空操作，如果二叉树非空，则执行以下操作：

1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树

二叉树的非递归算法实现，利用栈来实现二叉树的非递归算法

> 从二叉树的根结点开始，访问根结点，然后将该根结点的指针入栈，执行以下两个步骤
>
> 1. 如果该结点的左孩子结点存在，访问该左孩子结点，并将该孩子结点的指针入栈，重复执行此操作，直到结点的左孩子不存在
> 2. 将栈顶的元素出栈，若干该指针指向的右孩子结点存在，则将当前指针指向右孩子结点
>
> 重复执行以上两个步骤，直到栈空为止

##### 9.4.2 二叉树的中序遍历

如果二叉树为空，则执行空操作，如果二叉树非空，则执行以下操作：

1. 中序遍历左子树
2. 访问根节点
3. 中序遍历右子树

从中序遍历的序列可以看出，根结点左边的序列是根结点的左子树元素，右边是根结点的右子树序列

二叉树的非递归算法实现：

> 从二叉树的根结点开始，将根结点的指针入栈，执行以下两个步骤：
>
> 1. 如果该结点的左孩子结点存在，将左孩子结点的指针入栈，重复执行此操作，直到结点的左孩子不存在。
> 2. 将栈顶的元素出栈，并访问该指针指向的结点，如果该指针指向的右孩子结点存在，则将当前指针指向右孩子结点
>
> 重复执行步骤1和2，直到栈空为止

##### 9.4.3 二叉树的后序遍历

如果二叉树为空，则执行空操作，如果二叉树非空，则执行以下操作：

1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点

二叉树的非递归算法实现：

> 从二叉树的根结点开始，将根结点的指针入栈，执行以下两个步骤：
>
> 1. 如果该结点的左孩子结点存在，将左孩子结点的指针入栈，重复执行此操作，直到结点的左孩子不存在。
> 2. 取栈顶的元素并付给p，如果p.right==null或p.right=q，即p没有右孩子或右孩子结点已经访问过，则访问根结点，即p指向的结点，并用q记录刚访问过的结点指针，将栈顶元素退栈。如果p有右孩子且右孩子结点没有被访问过，则执行p = p.right。
>
> 重复执行步骤1和步骤2，直到栈空为止

##### 9.5.2 二叉树的输出

1. 创建一个二叉树，并按照层次输出二叉树的每个结点

> 通过利用一个队列，将每一层的结点依次进入队列，然后在输出队列元素的同时，将其孩子结点入队

##### 9.5.3 二叉树的计数

1. **统计二叉树的叶子结点个数**
   - 当P==NULL时，leaf(P) = 0
   - 当P的左右孩子均为空时，leaf(P) = 1
   - 其他情况 leaf(P) = leaf(P.left) + leaf(P.right)
2. **统计二叉树的非叶子结点的个数**
   - 当P==NULL时，notLeaf(P) = 0
   - 当P的左右孩子均为空时，notLeaf(P) = 0
   - 其他情况，notLeaf(P) = notLeaf(p.left)+notLeaf(p.right)+1
3. **计算二叉树的深度**
   - 当P==NULL时，depth(P) = 0
   - 当P的左右孩子均为空时，depth(P) = 1
   - 其他情况，depth(P) = max(depth(P.left),depth(P.right))+1

---

2017年02月06日 星期一

学习还是不能用力太猛，要不然容易产生厌倦的情绪，不利于以后的继续学习，学习应该是保持一种平和的心态，养成每天都学习的习惯，而不是埋头苦干3天，然后闲置30天。这样的学习方式是徒劳无功的。

我现在要做的事情就是每天都学习一点，每天都复习一点，每天都进步一点，这样，自然而然的，水到渠成。

加油吧！大叔

#### 二叉搜索树

二叉搜索树：一个节点的左子节点的关键字值小于这个节点，右子节点的关键字值大于或等于这个父节点

#### 查找节点

用变量current保存正在查看的节点，参数key是要找的值，查找从根开始，因此把current设为根

之后，在while循环中，将要查找的值key与当前节点的data字段的值做比较，如果key小于这个数据域的值，current设为此节点的左子节点，如果key大于或等于节点data的值，current设为此节点的右子节点

如果current等于null，在查找序列中找不到下一个子节点，表明了它不存在，返回null

如果while循环的条件不满足，从循环的末端退出来，这就说明找到该节点了，返回这个节点

#### 树的效率

查找节点的时间取决于这个节点所在的层数，它的时间复杂度是O(logN)

#### 插入一个节点

用一个新的变量parent，current的父节点，来存储遇到的最后一个不是null的节点

为了插入新节点，把parent中对应的子指针指向新节点，如果每找到parent的左子节点，就把新节点接到parent的左子节点处，没找到右子节点，就把新节点接到右子节点处

### 遍历树

#### 中序遍历

中序遍历二叉搜索树会使所有的节点按关键字值升序被访问到

遍历树的最简单的方法就是递归

中序遍历的步骤

1. 调用自身来遍历节点的左子树
2. 访问这个节点
3. 调用自身来遍历节点的右子树

#### 查找最大值和最小值

要找最小值时，先走到根的左子节点处，然后接着走到那个子节点的左子节点，如此类推，直到找到一个没有左子节点的节点。这个节点就是最小值的节点

要找最大值时，就一直向右找到没有右子节点的节点，这个节点就是最大值的节点

#### 删除节点

删除节点是二叉搜索树常用的一般操作中最复杂的

删除节点要从查找要删的节点开始入手，找到节点后，这个要删除的节点可能会有三中情况需要考虑：

1. 该节点是叶节点
2. 该节点有一个子节点
3. 该节点有两个子节点

---

希望今天能好好研究一下删除节点的方法，对自己以后学习hashmap原理的时候会有帮助，也可以让我更加深刻的理解到数据结构的作用和实现原理

**情况1：删除没有子节点的结点**

要删除叶节点，只需要改变该结点的父节点对应子字段的值，由指向该结点改为null就可以了

找到结点后，先要检查它是不是真的没有子节点，如果他没有子节点，还要检查他是否是根，如果他是根的话，只需要把他置为null

**情况2：删除有一个子节点的结点**

需要从序列中剪断这个结点，把他的子节点直接连到它的父节点上

有四种不同的情况：

要删除结点的子节点可能有左子节点或右子节点，并且每种情况中的要删除的结点也可能是自己的父节点的左子节点或右子节点

还有一种特殊的情况，被删除的结点是根，它没有父节点，指示被核实的子树所代替

**情况3：删除有两个子节点的结点**

用他的中序后继来代替该结点

### 图

**邻接**： 如果两个顶点被同一条边连接，就称这两个顶点是邻接的

**路径**： 路径是边的序列

**连通图**： 如果至少有一条路径可以连接起所有的顶点，那么这个图被称作连通的

**有向图和带权图**： 只能从A到B，而不能从B到A，就像单行道一样

为了模拟这种自由形式的组织结构，需要用一种不同的方法表示边，一般用两个方法表示图，邻接矩阵和邻接表

邻接矩阵是一个二维数组，数据项表表示两点讲是否存在边

有两种常用的方法可用来搜索图，深度优先搜索和广度优先搜索

**深度优先搜索通过栈来实现，而广度优先搜索通过队列实现**

#### 深度优先搜索

用栈记住下一步的走向

1. 首先访问该顶点，然后把该点放入栈中，以便记住它，最后标记该点，这样就不会再访问它了

**规则1：** 如果可能，访问一个邻接的未访问顶点，标记它，并把它放入栈中

**规则2：** 当不能执行规则1时，如果栈不空，就从栈中弹出一个顶点

**规则3：** 如果不能执行规则1和规则2，就完成了整个搜索过程

深度优先搜索的关键在于能够找到与某一顶点邻接且没有访问过的顶点，邻接矩阵是关键

它循环执行，直到栈为空，每次循环中，它做四件事

1. 用peek()方法检查栈顶的顶点
2. 试图找到这个顶点还未访问的邻接点
3. 如果没有找到，出栈
4. 如果找到这样的顶点，访问这个顶点，并把它放入栈

#### 广度优先搜索

A是起始点，所以访问它，并标记为当前顶点，然后引用下面几条规则

1. 访问下一个未访问的邻接点(如果存在)，这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中
2. 如果因为已经没有未访问顶点而不能执行规则1，那么从队列的头取一个顶点(如果存在)，并使其成为当前顶点
3. 如果因为队列为空而不能执行规则1和规则2，则搜索结束

#### 最小生成树

在在执行深度优先搜索过程中，记录走过的边，就可以创建一棵最小生成树

#### 红黑树

红-黑规则

1. 每一个节点不是红色就是黑色
2. 根总是黑色的
3. 如果节点是红色的，则它的子节点必须是黑色的(反之倒不一定必须为真)
4. 从根到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点


##### 特性

1. 每个结点或者是黑色，或者是红色
2. 根结点是黑色
3. 每个空叶子结点是黑色
4. **如果一个节点是红色，则它的子节点必须是黑色**
5. 从一个结点到该结点的子孙结点的所有路径上包含相同的黑结点

##### 添加操作

1. 将红黑树当作一颗二叉查找树，将节点插入

2. 将插入的节点着色为红色

3. 通过一系列的旋转或着色操作，使之重新成为一棵红黑树

   插入节点会违背哪些特性？

   1. 将插入的节点着色为红色之后，不会违背特性5
   2. 对于特性1，显然不会违背，因为已经涂成红色了
   3. 对于特性2，显示也不会违背，插入操作不会改变根结点，所以根结点仍然是黑色的
   4. 对于特性3，显然不会违背，插入非空叶子结点不会对它们造成影响
   5. 对于特性4，是有可能违背的，所以想方法满足特性4，就可以重新构造红黑树了

算法步骤：

1. 若父节点存在，并且父节点的颜色是红色，进入循环

2. 若父节点是祖父节点的左孩子，这时候分为三种情况：

   1. 叔叔结点为红色

      设置x的父节点的颜色为黑色

      设置x的叔叔结点的颜色为黑色

      设置x的祖父节点的颜色为红色

      将x等于x的祖父节点

   2. 叔叔结点是黑色，这时候又分为两种情况：

      1. 当前结点是右孩子

         设置x等于x的父节点

         左旋x结点，也就是相当于左旋父节点

      2. 当前结点是左孩子

         设置x的父节点的颜色为黑色

         设置x的祖父节点的颜色为红色

         右旋x的祖父节点

3. 若x的父节点是x的祖父节点的右孩子，也是分三种情况：

   1. 叔叔结点为红色

      设置x的父节点的颜色为黑色

      设置x的叔叔结点的颜色为黑色

      设置x的祖父节点的颜色为红色

      将x等于x的祖父节点

   2. 叔叔结点为黑色，又分为两种情况：

      1. 当前结点x结点是左孩子

         将x 等于x的父节点

         右旋x

      2. 当前结点x结点是右孩子

         设置x的父节点的颜色为黑色

         设置x的祖父节点的颜色为红色

         左旋x的祖父节点

4. 最后将根结点设置为黑色


#### 拓扑排序算法

思想虽然不同寻常但是很简单，有两个步骤是必需的：

1. 找到一个没有后继的顶点
2. 从图中删除这个顶点，在列表的前面插入顶点的标记

重复步骤1和步骤2，直到所有的顶点都从图中删除，这时候，列表显示的顶点顺序就是拓扑排序的结果

要 计算出无向图是否存在环也很简单，如果有N个顶点的图超过N-1条边，那么它必定存在环

具体步骤

1. 找到没有后继节点的顶点

   遍历边的二维矩阵，找到不包含`adjMat[row][col]>0 `的row，也就是说找到所有`adjMat[row][col]`都为0的row

   如果row存在，则返回该row

   如果遍历完之后不存在这样的行，则表示该有向图有环，退出

2. 找到该顶点后，将该顶点保存到一个有序数组中，从数组的后面往前面插入

   sortedArray[nVerts-1] = vertexList[currentIndex].label

3. 删除这个顶点

   这个删除方法是关键，分为两种情况

   如果该顶点是在二维矩阵的最后一行，则直接nVerts -1即可

   如果该顶点不是在二维矩阵的最后遗憾，则将该行删除，删除分为两步

   将该行的下面所有的行往上移

   将该列的右边所有的列往左移

   记得要把保存顶点的数组中的该顶点删除，然后移动后面的元素

4. 最后打印有序数组，即是拓扑排序的结果

#### warshall算法

如果能从顶点L到M，并且能从顶点M到N，那么可以从L到N

原图的传递闭包

使用该算法把邻接矩阵变成图的传递闭包

实现

使用三层嵌套循环，外层循环考察每一行，称它为变量y，它里面的一层循环考察行中的每个单元，它使用变量x，如果在单元(x,y)发现1，那么表明有一条边从y到x，这时候执行最里层循环，它使用变量z，第三个循环检查y的每个单元，看是否有边以y为终点，如果行z列y值为1，说明有一条边从z到y，把单元(z,x)置为1

### 带权图

使用优先级队列来实现这个用于反复选择最小造价的表，而不用链表或数组

在正式的程序中，优先级可能使用堆来实现

算法要点

从一个顶点开始，把它放入树的集合中，然后重复做下面的事情：

1. 找到从最新的顶点到其他顶点的所有边，这些顶点不能在树的集合中，把这些边放入优先级队列
2. 找出权值最小的边，把它和它所到达的顶点放入树的集合中

重复这些步骤，直到所有的顶点都在树的集合中，这时，工作完成

#### 贪心法

贪心算法，是一种在每一步选择中都采取当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法

使用贪心法解决的经典问题：

1. Travelling Salesman Problem
2. Prim's Minimal Spanning Tree Algorithm
3. Kruskal's Minimal Spanning Tree Algorithm
4. Dijkstra's Minimal Spanning Tree Algorithm
5. Knapsack Problem
6. Job Scheduling Problem

贪心算法是在有最优子结构的问题中尤为有效

---

### Union-Find 

基础抽象：

1. 对象集合
2. **union** 命令：连接两个对象
3. **find** 查询： 是否有路径连接两个对象

实现思路

1. 建立n个分组，每个分组代表一堆可以互相连通的结点
2. 遍历每对结点，找到它们各自所属的分组A，B
3. 如果A！=B，则将A，B分组union起来，表示A，B分组连通了
4. 如果A==B，则跳过


这个算法也是非常重要的，一定要掌握啊，是kruskal算法的核心基础，必须要理解和掌握

### 最短路径问题

有向带权图

Dijkstra算法，这个算法的实现基于图的邻接矩阵表示法

难题

1. 骑士周游
2. 旅行商问题
3. 汉密尔顿回路

该算法把所有的顶点分成两个不同的集合，一个已结算，一个未结算，初始化所有的结点到未结算的集合，一个结点被移动到已结算集合，如果从源到该结点有一个最短路径被找到



这本书还是要继续看的，下面开始进入java的复习的

今年的主要目标还是数据结构和算法的学习，其中算法是重中之重，必须要熟练掌握

