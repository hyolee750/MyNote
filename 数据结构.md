这次一定要坚持到底的将数据结构的学习进行下去，不能半途而废，同时也要温故知新，不断的提高自身的知识水平

新的一年，希望能完成的几个小目标之一

1. 熟练掌握各种数据结构，比如线性表，栈，队列，串，数组，广义表，树，图等结构的实现原理，思想，优点，缺点等
2. 熟练掌握各种算法，算法和数据结构才是程序，只有把这两项掌握好了，可以胜任任何语言的工作
3. 开始大数据入门，随着最近互联网的大热，大数据越来越重要，这也是我今后将要研究的课题

那么，就从数据结构开始吧，我希望自己不仅仅是记下来一些要点就不看了，一定要经常看看自己的笔记，从自己总结的经验中得到思考，并加深自己的印象，让知识存在脑海中，而不是笔记本上

### 线性表

#### 线性表的逻辑结构

线性表是由n个类型相同的数据元素组成的有限序列

线性表的数据元素之间具有一定的顺序

除了第一个元素外，每个元素有且仅有一个直接前驱元素

除了最后一个元素外，每个元素有且只有一个直接后继元素

#### 基本操作集合

1. InitList() 初始化操作，构造一个空的线性表
2. isEmpty() 判断线性表是否为空，是返回true，否返回false
3. get(int index) 根据索引获取线性表中的元素
4. indexOf(E e) 获取元素在线性表中的位置
5. add(E e) 插入元素
6. remove(E e) 删除元素
7. length() 返回线性表的长度
8. clear() 清空线性表

#### 线性表的顺序表示和实现

线性表的顺序存储是指将线性表中的元素存放在一组连续的存储单元中，这样的存储方式使得线性表逻辑上相邻的元素，其在物理存储单元也是相邻的

线性表的顺序存储结构是一种随机存储的存储结构

数组具有随机存取数组中的元素占用连续的存储空间，因此，采用数组描述线性表的顺序存储结构

#### 顺序表的实现算法分析

除了按内容查找运算，插入和删除操作外，算法的时间复杂度都为O(1)。

在按内容查找算法中，查找元素需要比较的平均次数为(n+1)/2，所以平均时间复杂度为O(n)。

在插入算法中，时间的耗费主要集中在移动元素上，在顺序表中插入操作需要移动元素的平均次数为n/2，所以插入操作的平均时间复杂度为O(n)。

在删除算法中，时间耗费同样在移动元素上，删除操作需要移动元素的平均次数为(n-1)/2，所以删除操作的平均时间复杂度为O(n)。

#### 顺序表的应用举例

应用1： 如果在顺序表A中出现的元素，在顺序表B中也出现，则将顺序表A中的该元素删除

分析实现思路：

> 1. 依次把B中的每个元素取出给e
> 2. 在A中查找和B中取出的元素e相等的元素
> 3. 如果找到该元素，将其从A中删除

```java
public static void deleteElement(int[] a, int[] b) {
  int r = 0, w = 0;
  int size = a.length;
  try {
    for (; r < size; r++)
      if (!contains(b, a[r]))
        a[w++] = a[r];
  } finally {
    if (w != size) 
      for (int i = w; i < size; i++)
        a[i] = 0;
  }
}
```

应用2： 顺序表A和顺序表B的元素是非递减排列，利用线性表的基本运算，将它们合并成一个顺序表C，要求顺序表C也是非递减排列。

分析实现思路：

> 1. 取出顺序表A和B中的元素，并将这两个元素进行比较
> 2. 如果A中的元素m1大于B中的元素n1，则将B中的元素n1插入到C中，继续取出B中下一个元素n2与A中的元素m1比较
> 3. 如果A中的元素m1小于B中的元素n1，则将A中的元素m1插入到C中，继续取出A中下一个元素m2与B中元素n1比较，依次类推，直到一个表中的元素比较完毕
> 4. 将另外一个表中剩余元素插入到C中

代码实现：

```java
private int[] merge(int[] a, int[] b) {
  int[] c = new int[a.length + b.length];
  int i = 0, j = 0, k = 0;
  while (i < a.length && j < b.length) {
    if (a[i] <= b[j]) c[k++] = a[i++];
    else c[k++] = b[j++];
  }
  while (i < a.length) c[k++] = a[i++];
  while (j < b.length) c[k++] = b[j++];
  return c;
}
```

#### 线性表的链式表示与实现

在顺序表中，由于逻辑上相邻的元素其物理位置也相邻，因此可以随机存储顺序表中的任何一个元素。但是顺序表也存在着缺点，插入和删除运算需要移动大量的元素，存储分配必须事先进行分配，事先分配的存储单元的大小可能不适合问题的需要

#### 单链表的存储结构

线性表的链式存储是采用一组任意的存储单元存放线性表的元素，可以连续也可以不连续

以结点作为存储结构

结点包含两个域：数据域和指针域，其中数据域存放数据元素的信息，指针域存放元素的直接后继的存储地址

#### 循环单链表

循环单链表是一种首尾相连的单链表，它是在单链表的基础上，将单链表的最后一个节点的指针域由NULL变成指向单链表的头结点或第一个结点

循环单链表也有带头结点结构和不带头结点结构两种

循环单链表不为空时，最后一个结点的指针域指向头结点，循环单链表为空时，头结点指针域指向头结点本身

判断链表是否为空的条件 head->next == head

将两个设置尾指针的循环单链表合并只需要三步ckz操作：

1. LA->next = LB->next->next，将LA的表尾与LB的第一个结点相连
2. free(LB->next)，释放LB的头结点
3. LB->next = LA->next，将LB的表尾与LA的表头相连

约瑟夫问题。有n个人，编号为1,2,3,...,n，围成一个圆圈，按照顺时针方向从编号为k的人从1开始报数，报数为m的人出列，他的下一个人重新开始从1报数，数到m的人出列，如此重复下去，直到所有人都出列，编写一个算法，要求输入n，k，m，按照出列的顺序输出编号

分析：

1. 建立一个具有n个结点的不带头结点的循环单链表，编号从1到n，代表n个人
2. 找到第k个结点，即第一个开始报数的人
3. 编号为k的人从1开始报数，并开始计数，报到m的人出列，即将该结点删除

#### 双向链表

双向链表是指链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点

##### 双向链表的存储结构

在双向链表中，每个结点包括三个域，data域，prior域和next域

data域为数据域，用来存放数据元素

##### 双向链表的插入操作和删除操作

插入操作:

算法思想：首先找到第i个结点，用p指向该结点，再申请一个新结点，由s指向该结点，将e放入到数据域中。然后开始修改p和s指向的结点的指针域：修改s的prior域，使其指向p的直接前驱结点，即s->prior = p->prior，修改p的直接前驱结点的next域，使其指向s所指向的结点，即p->prior->next = s，修改s的next域，使其指向p指向的结点，即s->next = p，修改p的prior域，使其指向s指向的结点，即p->prior = s

1. s->prior = p->prior
2. p->prior->next = s
3. s->next = p
4. p->prior = s

删除操作：

1. 修改p的前驱结点的next域，使其指向p的直接后继结点，p->prior->next=p->next
2. 修改p的直接后继结点的prior域，使其指向p的直接前驱结点，即p->next->prior=p->prior

插入和删除操作的时间复杂度都为O(1)

---

2017年2月3日 星期五

第一天上班，努力工作，好好学习，这个星期争取把树的知识和一些经典的算法学会，下个星期学习图，这次不再从前面开始学了，从后面开始学习

### 第9章 树

本章的主要学习内容包括树的定义，二叉树的定义与特质，二叉树的存储表示与实现，二叉树的遍历，二叉树的线索化，树与森林的转换及哈夫曼树

#### 9.1 树的定义及抽象数据类型

##### 9.1.1 树的定义

树是n(n>=0)个结点的有限序列，其中，n=0时，称为空树。当n>0时，称为非空树，满足以下条件：

1. 有且只有一个称为根的结点
2. 当n>1时，其余n-1个结点可以划分为m个有限集合，且这m个有限集合不相交，其中的一个T又是一棵树，称为根的子树。

树是一个递归的定义

下面介绍关于树的一些基本概念

**树的结点：** 包含一个数据元素及若干指向子树分支的信息

**结点的度：** 一个结点拥有子树的个数称为结点的度

**叶子结点：** 没有子树的结点也就是度为0的结点称为叶子结点

**分支结点：** 也称为非终端结点，度不为零的结点称为非终端结点

**孩子结点：** 一个结点的子树的根结点称为孩子结点

**双亲结点：** 也称父结点，如果一个结点存在孩子结点，则该结点就称为孩子结点的双亲结点

**子孙结点：** 在一个根结点的子树的任何一个结点都称为该根结点的子孙结点

**树的度：** 树中所有结点的度的最大值

**树的层次：** 从根结点开始，根结点位于第一层，根结点的孩子结点位于第二层，以此类推。

**树的深度：** 也称为树的高度，树中所有结点的层次最大值称为树的深度

#### 9.2 二叉树

##### 9.2.1 二叉树的定义

二叉树中的每个结点最多只有两棵子树

二叉树中的每个结点都有左右次序之分，次序不能颠倒

二叉树中的每个结点的度只可能是0,1,2

位于左边的孩子结点称为左孩子

位于右边的孩子结点称为右孩子

如果n=0，则称该二叉树为空二叉树

**满二叉树：** 每层结点都是满的二叉树

**完全二叉树：** 如果一颗二叉树有n个结点，并且二叉树的n个结点的结构与满二叉树的前n个结点的结构完全相同，这样的二叉树为完全二叉树

##### 9.2.2 二叉树的性质

**性质1：在二叉树中，第m层(m>=1)上至多有2^(m-1)个结点**

**性质2：深度为k(k>=1)的二叉树至多有2^k -1个结点**

**性质3：对任何一棵二叉树T，如果叶子结点总数为n0，度为2的结点总数为n2，则有n0=n2+1**

**性质4：如果完全二叉树有n个结点 ，则深度为log2(n)+1** 

#### 9.3 二叉树的存储表示与实现

##### 9.3.1 二叉树的顺序存储

完全二叉树的存储可以按照从上到下，从左到右的顺序依次存储在一维数组中

##### 9.3.2 二叉树的链式存储

二叉树的链式存储结构包含三个域：**数据域，左孩子指针域和右孩子指针域** ，其中，数据域存储该结点的值，左孩子指针域指向左孩子结点，右孩子指针域指向右孩子结点

#### 9.4 二叉树的遍历

##### 9.4.1 二叉树的先序遍历

如果二叉树为空，则执行空操作，如果二叉树非空，则执行以下操作：

1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树

二叉树的非递归算法实现，利用栈来实现二叉树的非递归算法

> 从二叉树的根结点开始，访问根结点，然后将该根结点的指针入栈，执行以下两个步骤
>
> 1. 如果该结点的左孩子结点存在，访问该左孩子结点，并将该孩子结点的指针入栈，重复执行此操作，直到结点的左孩子不存在
> 2. 将栈顶的元素出栈，若干该指针指向的右孩子结点存在，则将当前指针指向右孩子结点
>
> 重复执行以上两个步骤，直到栈空为止

##### 9.4.2 二叉树的中序遍历

如果二叉树为空，则执行空操作，如果二叉树非空，则执行以下操作：

1. 中序遍历左子树
2. 访问根节点
3. 中序遍历右子树

从中序遍历的序列可以看出，根结点左边的序列是根结点的左子树元素，右边是根结点的右子树序列

二叉树的非递归算法实现：

> 从二叉树的根结点开始，将根结点的指针入栈，执行以下两个步骤：
>
> 1. 如果该结点的左孩子结点存在，将左孩子结点的指针入栈，重复执行此操作，直到结点的左孩子不存在。
> 2. 将栈顶的元素出栈，并访问该指针指向的结点，如果该指针指向的右孩子结点存在，则将当前指针指向右孩子结点
>
> 重复执行步骤1和2，直到栈空为止

##### 9.4.3 二叉树的后序遍历

如果二叉树为空，则执行空操作，如果二叉树非空，则执行以下操作：

1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点

二叉树的非递归算法实现：

> 从二叉树的根结点开始，将根结点的指针入栈，执行以下两个步骤：
>
> 1. 如果该结点的左孩子结点存在，将左孩子结点的指针入栈，重复执行此操作，直到结点的左孩子不存在。
> 2. 取栈顶的元素并付给p，如果p.right==null或p.right=q，即p没有右孩子或右孩子结点已经访问过，则访问根结点，即p指向的结点，并用q记录刚访问过的结点指针，将栈顶元素退栈。如果p有右孩子且右孩子结点没有被访问过，则执行p = p.right。
>
> 重复执行步骤1和步骤2，直到栈空为止

##### 9.5.2 二叉树的输出

1. 创建一个二叉树，并按照层次输出二叉树的每个结点

> 通过利用一个队列，将每一层的结点依次进入队列，然后在输出队列元素的同时，将其孩子结点入队

##### 9.5.3 二叉树的计数

1. **统计二叉树的叶子结点个数**
   - 当P==NULL时，leaf(P) = 0
   - 当P的左右孩子均为空时，leaf(P) = 1
   - 其他情况 leaf(P) = leaf(P.left) + leaf(P.right)
2. **统计二叉树的非叶子结点的个数**
   - 当P==NULL时，notLeaf(P) = 0
   - 当P的左右孩子均为空时，notLeaf(P) = 0
   - 其他情况，notLeaf(P) = notLeaf(p.left)+notLeaf(p.right)+1
3. **计算二叉树的深度**
   - 当P==NULL时，depth(P) = 0
   - 当P的左右孩子均为空时，depth(P) = 1
   - 其他情况，depth(P) = max(depth(P.left),depth(P.right))+1

---

2017年02月06日 星期一

学习还是不能用力太猛，要不然容易产生厌倦的情绪，不利于以后的继续学习，学习应该是保持一种平和的心态，养成每天都学习的习惯，而不是埋头苦干3天，然后闲置30天。这样的学习方式是徒劳无功的。

我现在要做的事情就是每天都学习一点，每天都复习一点，每天都进步一点，这样，自然而然的，水到渠成。

加油吧！大叔

#### 二叉搜索树

二叉搜索树：一个节点的左子节点的关键字值小于这个节点，右子节点的关键字值大于或等于这个父节点

#### 查找节点

用变量current保存正在查看的节点，参数key是要找的值，查找从根开始，因此把current设为根

之后，在while循环中，将要查找的值key与当前节点的data字段的值做比较，如果key小于这个数据域的值，current设为此节点的左子节点，如果key大于或等于节点data的值，current设为此节点的右子节点

如果current等于null，在查找序列中找不到下一个子节点，表明了它不存在，返回null

如果while循环的条件不满足，从循环的末端退出来，这就说明找到该节点了，返回这个节点

#### 树的效率

查找节点的时间取决于这个节点所在的层数，它的时间复杂度是O(logN)

#### 插入一个节点

用一个新的变量parent，current的父节点，来存储遇到的最后一个不是null的节点

为了插入新节点，把parent中对应的子指针指向新节点，如果每找到parent的左子节点，就把新节点接到parent的左子节点处，没找到右子节点，就把新节点接到右子节点处

### 遍历树

#### 中序遍历

中序遍历二叉搜索树会使所有的节点按关键字值升序被访问到

遍历树的最简单的方法就是递归

中序遍历的步骤

1. 调用自身来遍历节点的左子树
2. 访问这个节点
3. 调用自身来遍历节点的右子树

#### 查找最大值和最小值

要找最小值时，先走到根的左子节点处，然后接着走到那个子节点的左子节点，如此类推，直到找到一个没有左子节点的节点。这个节点就是最小值的节点

要找最大值时，就一直向右找到没有右子节点的节点，这个节点就是最大值的节点

#### 删除节点

删除节点是二叉搜索树常用的一般操作中最复杂的

删除节点要从查找要删的节点开始入手，找到节点后，这个要删除的节点可能会有三中情况需要考虑：

1. 该节点是叶节点
2. 该节点有一个子节点
3. 该节点有两个子节点

---

希望今天能好好研究一下删除节点的方法，对自己以后学习hashmap原理的时候会有帮助，也可以让我更加深刻的理解到数据结构的作用和实现原理

**情况1：删除没有子节点的结点**

要删除叶节点，只需要改变该结点的父节点对应子字段的值，由指向该结点改为null就可以了

找到结点后，先要检查它是不是真的没有子节点，如果他没有子节点，还要检查他是否是根，如果他是根的话，只需要把他置为null

**情况2：删除有一个子节点的结点**

需要从序列中剪断这个结点，把他的子节点直接连到它的父节点上

有四种不同的情况：

要删除结点的子节点可能有左子节点或右子节点，并且每种情况中的要删除的结点也可能是自己的父节点的左子节点或右子节点

还有一种特殊的情况，被删除的结点是根，它没有父节点，指示被核实的子树所代替

**情况3：删除有两个子节点的结点**

用他的中序后继来代替该结点

### 图

**邻接**： 如果两个顶点被同一条边连接，就称这两个顶点是邻接的

**路径**： 路径是边的序列

**连通图**： 如果至少有一条路径可以连接起所有的顶点，那么这个图被称作连通的

**有向图和带权图**： 只能从A到B，而不能从B到A，就像单行道一样

为了模拟这种自由形式的组织结构，需要用一种不同的方法表示边，一般用两个方法表示图，邻接矩阵和邻接表

邻接矩阵是一个二维数组，数据项表表示两点讲是否存在边

有两种常用的方法可用来搜索图，深度优先搜索和广度优先搜索

**深度优先搜索通过栈来实现，而广度优先搜索通过队列实现**

#### 深度优先搜索

用栈记住下一步的走向

1. 首先访问该顶点，然后把该点放入栈中，以便记住它，最后标记该点，这样就不会再访问它了

**规则1：** 如果可能，访问一个邻接的未访问顶点，标记它，并把它放入栈中

**规则2：** 当不能执行规则1时，如果栈不空，就从栈中弹出一个顶点

**规则3：** 如果不能执行规则1和规则2，就完成了整个搜索过程

深度优先搜索的关键在于能够找到与某一顶点邻接且没有访问过的顶点，邻接矩阵是关键

它循环执行，直到栈为空，每次循环中，它做四件事

1. 用peek()方法检查栈顶的顶点
2. 试图找到这个顶点还未访问的邻接点
3. 如果没有找到，出栈
4. 如果找到这样的顶点，访问这个顶点，并把它放入栈

#### 广度优先搜索

A是起始点，所以访问它，并标记为当前顶点，然后引用下面几条规则

1. 访问下一个未访问的邻接点(如果存在)，这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中
2. 如果因为已经没有未访问顶点而不能执行规则1，那么从队列的头取一个顶点(如果存在)，并使其成为当前顶点
3. 如果因为队列为空而不能执行规则1和规则2，则搜索结束

#### 最小生成树

在在执行深度优先搜索过程中，记录走过的边，就可以创建一棵最小生成树

