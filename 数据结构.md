这次一定要坚持到底的将数据结构的学习进行下去，不能半途而废，同时也要温故知新，不断的提高自身的知识水平

新的一年，希望能完成的几个小目标之一

1. 熟练掌握各种数据结构，比如线性表，栈，队列，串，数组，广义表，树，图等结构的实现原理，思想，优点，缺点等
2. 熟练掌握各种算法，算法和数据结构才是程序，只有把这两项掌握好了，可以胜任任何语言的工作
3. 开始大数据入门，随着最近互联网的大热，大数据越来越重要，这也是我今后将要研究的课题

那么，就从数据结构开始吧，我希望自己不仅仅是记下来一些要点就不看了，一定要经常看看自己的笔记，从自己总结的经验中得到思考，并加深自己的印象，让知识存在脑海中，而不是笔记本上

### 线性表

#### 线性表的逻辑结构

线性表是由n个类型相同的数据元素组成的有限序列

线性表的数据元素之间具有一定的顺序

除了第一个元素外，每个元素有且仅有一个直接前驱元素

除了最后一个元素外，每个元素有且只有一个直接后继元素

#### 基本操作集合

1. InitList() 初始化操作，构造一个空的线性表
2. isEmpty() 判断线性表是否为空，是返回true，否返回false
3. get(int index) 根据索引获取线性表中的元素
4. indexOf(E e) 获取元素在线性表中的位置
5. add(E e) 插入元素
6. remove(E e) 删除元素
7. length() 返回线性表的长度
8. clear() 清空线性表

#### 线性表的顺序表示和实现

线性表的顺序存储是指将线性表中的元素存放在一组连续的存储单元中，这样的存储方式使得线性表逻辑上相邻的元素，其在物理存储单元也是相邻的

线性表的顺序存储结构是一种随机存储的存储结构

数组具有随机存取数组中的元素占用连续的存储空间，因此，采用数组描述线性表的顺序存储结构

#### 顺序表的实现算法分析

除了按内容查找运算，插入和删除操作外，算法的时间复杂度都为O(1)。

在按内容查找算法中，查找元素需要比较的平均次数为(n+1)/2，所以平均时间复杂度为O(n)。

在插入算法中，时间的耗费主要集中在移动元素上，在顺序表中插入操作需要移动元素的平均次数为n/2，所以插入操作的平均时间复杂度为O(n)。

在删除算法中，时间耗费同样在移动元素上，删除操作需要移动元素的平均次数为(n-1)/2，所以删除操作的平均时间复杂度为O(n)。

#### 顺序表的应用举例

应用1： 如果在顺序表A中出现的元素，在顺序表B中也出现，则将顺序表A中的该元素删除

分析实现思路：

> 1. 依次把B中的每个元素取出给e
> 2. 在A中查找和B中取出的元素e相等的元素
> 3. 如果找到该元素，将其从A中删除

```java
public static void deleteElement(int[] a, int[] b) {
  int r = 0, w = 0;
  int size = a.length;
  try {
    for (; r < size; r++)
      if (!contains(b, a[r]))
        a[w++] = a[r];
  } finally {
    if (w != size) 
      for (int i = w; i < size; i++)
        a[i] = 0;
  }
}
```

应用2： 顺序表A和顺序表B的元素是非递减排列，利用线性表的基本运算，将它们合并成一个顺序表C，要求顺序表C也是非递减排列。

分析实现思路：

> 1. 取出顺序表A和B中的元素，并将这两个元素进行比较
> 2. 如果A中的元素m1大于B中的元素n1，则将B中的元素n1插入到C中，继续取出B中下一个元素n2与A中的元素m1比较
> 3. 如果A中的元素m1小于B中的元素n1，则将A中的元素m1插入到C中，继续取出A中下一个元素m2与B中元素n1比较，依次类推，直到一个表中的元素比较完毕
> 4. 将另外一个表中剩余元素插入到C中

代码实现：

```java
private int[] merge(int[] a, int[] b) {
  int[] c = new int[a.length + b.length];
  int i = 0, j = 0, k = 0;
  while (i < a.length && j < b.length) {
    if (a[i] <= b[j]) c[k++] = a[i++];
    else c[k++] = b[j++];
  }
  while (i < a.length) c[k++] = a[i++];
  while (j < b.length) c[k++] = b[j++];
  return c;
}
```

#### 线性表的链式表示与实现

在顺序表中，由于逻辑上相邻的元素其物理位置也相邻，因此可以随机存储顺序表中的任何一个元素。但是顺序表也存在着缺点，插入和删除运算需要移动大量的元素，存储分配必须事先进行分配，事先分配的存储单元的大小可能不适合问题的需要

#### 单链表的存储结构

线性表的链式存储是采用一组任意的存储单元存放线性表的元素，可以连续也可以不连续

以结点作为存储结构

结点包含两个域：数据域和指针域，其中数据域存放数据元素的信息，指针域存放元素的直接后继的存储地址

#### 循环单链表

循环单链表是一种首尾相连的单链表，它是在单链表的基础上，将单链表的最后一个节点的指针域由NULL变成指向单链表的头结点或第一个结点

循环单链表也有带头结点结构和不带头结点结构两种

循环单链表不为空时，最后一个结点的指针域指向头结点，循环单链表为空时，头结点指针域指向头结点本身

判断链表是否为空的条件 head->next == head

将两个设置尾指针的循环单链表合并只需要三步ckz操作：

1. LA->next = LB->next->next，将LA的表尾与LB的第一个结点相连
2. free(LB->next)，释放LB的头结点
3. LB->next = LA->next，将LB的表尾与LA的表头相连

约瑟夫问题。有n个人，编号为1,2,3,...,n，围成一个圆圈，按照顺时针方向从编号为k的人从1开始报数，报数为m的人出列，他的下一个人重新开始从1报数，数到m的人出列，如此重复下去，直到所有人都出列，编写一个算法，要求输入n，k，m，按照出列的顺序输出编号

分析：

1. 建立一个具有n个结点的不带头结点的循环单链表，编号从1到n，代表n个人
2. 找到第k个结点，即第一个开始报数的人
3. 编号为k的人从1开始报数，并开始计数，报到m的人出列，即将该结点删除

#### 双向链表

双向链表是指链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点

##### 双向链表的存储结构

在双向链表中，每个结点包括三个域，data域，prior域和next域

data域为数据域，用来存放数据元素

##### 双向链表的插入操作和删除操作

插入操作:

算法思想：首先找到第i个结点，用p指向该结点，再申请一个新结点，由s指向该结点，将e放入到数据域中。然后开始修改p和s指向的结点的指针域：修改s的prior域，使其指向p的直接前驱结点，即s->prior = p->prior，修改p的直接前驱结点的next域，使其指向s所指向的结点，即p->prior->next = s，修改s的next域，使其指向p指向的结点，即s->next = p，修改p的prior域，使其指向s指向的结点，即p->prior = s

1. s->prior = p->prior
2. p->prior->next = s
3. s->next = p
4. p->prior = s

删除操作：

1. 修改p的前驱结点的next域，使其指向p的直接后继结点，p->prior->next=p->next
2. 修改p的直接后继结点的prior域，使其指向p的直接前驱结点，即p->next->prior=p->prior

插入和删除操作的时间复杂度都为O(1)

