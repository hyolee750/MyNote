### 开闭原则

一个软件实体应对扩展开放，对修改关闭

1. 通过扩展已有的软件系统，可以通过新的行为，以满足对软件的新需求
2. 已有的软件模块，特别是最重要的抽象层模块不能再修改

解决问题的关键在于抽象化

里氏替换原则：任何基类可以出现的地方，子类一定可以出现

实现开闭原则的关键步骤是抽象化，里氏替换原则是对实现抽象化的具体步骤的规范

依赖倒转原则：要依赖于抽象，不要依赖于实现

聚合复用原则：要尽量使用合成/聚合，而不是继承关系达到复用的目的

迪米特法则：一个软件实体应该与尽可能少的其他实体发生相互作用

接口隔离原则：应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口

策略模式就是从对可变性的封装原则出发，达到开闭原则的一个范例

**将条件转移语句改写成为多态性**是一条广为流传的代码重构做法

### 寻找可变性的线索

java语言是类型安全的，通过以下三种方式完成该功能

1. 编译期的类型检查
2. 自动的存储管理
3. 数组的边界检查

### 接口

一个方法的特征仅包括方法的名字，参数的数目和种类，而不包括方法的返回类型，参量的名字以及所抛出的异常

在java编译器检查方法的重载时，会根据这些条件判断两个方法是否重载了

但是在java编译器检查方法覆盖时，则会进一步检查两个方法的返回类型和所抛出的异常是否相同

1. java接口本身没有任何实现
2. 一个java接口的方法只能是抽象的和公开的，接口不能有构造函数
3. 接口仅仅描述方法的特征，而不给出方法的实现

### 抽象类

抽象类仅提供一个类型的部分实现，抽象类可以有实例变量，以及构造函数。抽象类可以同时有抽象方法具体方法

一个抽象类不会有实例

只要有可能，不要从具体类继承

在一个以继承关系形成的等级结构里面，树叶节点均应当为具体类，而树枝节点均应当是抽象类

抽象类应当拥有尽可能多的共同代码

抽象类应当拥有尽可能少的数据

### 里氏替换原则

面向对象设计的重要原则就是创建抽象化，并且从抽象化导出具体化

从抽象化到具体化的导出要使用继承关系和里氏替换原则

里氏替换原则的严格表达：

> 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有变化，那么T2就是T1的子类型

里氏替换原则是继承复用的基石

里氏替换原则讲的是基类和子类的关系，只有当这种关系存在时，里氏替换关系才存在，反之则不存在

一般而言，如果两个具体类A和B有继承关系，那么一个最简单的方案应当是建立一个抽象类C，然后让类A和B成为抽象类C的子类

### 依赖倒转原则

要依赖于抽象，不要依赖于具体

在面向对象的系统里，两个类之间可以发生三种不同的耦合关系：

1. 零耦合关系：如果两个类没有耦合关系，就称为零耦合关系
2. 具体耦合关系，具体性耦合关系发生在两个具体的类之间，经由一个类对另外一个具体类的直接引用造成
3. 抽象耦合关系，发生在一个具体类和一个抽象类之间，使两个类之间发生最大的灵活性

抽象不应当依赖于细节，细节应当依赖于抽象

要针对接口编程，不要针对实现编程

变量被声明时的类型叫做变量的静态类型，也叫明显类型，变量所引用的对象的真实类型叫做变量的实际类型

以抽象方式耦合是依赖倒转原则的关键，里氏替换原则是依赖倒转原则的基础

### 接口隔离原则

一个类对另外一个类的依赖性应当建立在最小的接口上

### 合成/聚合复用原则

要尽量使用合成/聚合，尽量不要使用继承

合成/聚合的好处：

1. 新对象存取成分对象的唯一方法是通过成分对象的接口
2. 这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的
3. 这种复用支持包装
4. 这种复用所需依赖较少
5. 每一个新的类可以将焦点集中到一个任务上
6. 这种复用可以在运行时间内动态进行，新对象可以动态的引用与成分对象类型相同的对象

### 迪米特法则

迪米特法则主要用意是控制信息的过载，要注意以下几点:

1. 在类的划分上，应当创建有弱耦合的类
2. 在类的结构设计上，每一个类都应当尽可能的降低成员的访问权限
3. 在类的设计上，只要有可能，一个类应当设计成不变类
4. 在对其他类的引用上，一个对象对其对象引用应当降到最低

在需要一个变量的时候才声明它，可以有效的限制局部变量的有效范围

## 创建模式

创建模式是对类的实例化过程的抽象化

创建模式分为类的创建模式和对象的创建模式两种：

1. 类的创建模式使用继承，把类的创建延迟到子类、
2. 对象的创建模式是把对象的创建过程动态的委派给另一个对象，从而动态的决定客户端将得到哪些具体类的实例

创建模式主要包括以下几种：

1. 简单工厂模式
2. 工厂方法模式
3. 抽象工厂模式
4. 单例模式
5. 多例模式
6. 建造模式
7. 原始模型模式

### 简单工厂模式

简单工厂是类的创建模式，也叫做静态工厂方法模式，由一个工厂对象决定创建出哪一种产品类的实例

工厂模式的几种形态：

1. 简单工厂模式 也叫静态工厂方法模式
2. 工厂方法模式 叫多态性工厂模式或虚拟构造子模式
3. 抽象工厂模式 又称工具箱模式

#### 简单工厂模式的结构

三个角色

1. 工厂类Creator角色：担任这个角色的是工厂方法模式的核心，含有与应用紧密相关的商业逻辑，工厂类在客户端的直接调用下创建产品对象，它往往由一个具体的java类实现
2. 抽象产品角色：担任这个角色的类是由工厂方法模式所创建的对象的父类，或他们共同拥有的接口，可以用一个java接口或者java抽象类实现
3. 具体产品角色：工厂方法模式创建的任何对象都是这个角色的实例，具体产品角色由一个具体java类实现

工厂角色与抽象产品角色合并

工厂角色可以由抽象产品角色扮演，典型的应用就是`java.text.DateFormat`类，一个抽象产品类同时是子类的工厂

简单工厂模式的优缺点：

---

《Java与模式》这本书还是不错的，大概有1000多页，详细的介绍了设计模式的原则和26种设计模式，且对每种设计模式的用法，优缺点提供了详细的说明，是一本值得多次阅读的好书

也希望自己可以多读几遍这样的书，理解和熟练运用设计模式的思想 完成开发的任务，提供自己的设计思想和编码能力，写出更加优美和简洁的代码

2016年11月30日 星期三 

2016年快要过去了，还有一个月的时间，留给我的时间不多了，希望明年3月份跳槽的时候，可以有自信提出12k或者15k的工资水平

其实我是3月份开始做java，到明年3月份的时候正好一年，虽然我知道自己只有1年的实际工作经验，但是我现在的水平却相当于3年的水平

所以下次工资开始就不能再低于10k了

那么我接下来要学习和复习哪些东西呢？

1. 数据结构和算法，这个也是值得我看的 
2. java基础，内存模型，java集合，java io流，java nio，java并发，java lambda表达式 
3. 设计模式

加油吧，也不能浪费自己的时间了，毕竟自己现在也不小了，明年就28了，希望在30岁之前可以有20w到30w的存款，当然了，我知道这也是比较困难的，但是我会努力的，希望我自己可以成功

### 工厂方法模式

工厂方法模式是类的创建模式，定义了一个创建产品对象的工厂接口，将实际创建工作推迟到子类中

#### 简单工厂的优缺点

1. 允许客户端相对独立于产品创建过程，并且在系统引入新产品时无须修改客户端，在某种程度上支持开闭原则
2. 对开闭原则支持的不够，因为如果有新产品加入到系统中，就需要修改工厂类，将必要的逻辑加入到工厂类中

#### 工厂方法模式的改进

在工厂方法模式中，核心的工厂类不再负责所有产品的创建过程，而是将具体创建的工作交给子类去做，该核心类称为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节

#### 工厂方法模式的结构

角色：

1. 抽象工厂角色：担任这个角色的是工厂方法模式的核心，它与应用程序是无关的，任何在模式中创建对象的工厂类必须实现这个接口，通常由抽象java类实现
2. 具体工厂角色：实现了抽象工厂接口的具体java类，含有与应用密切相关的逻辑
3. 抽象产品角色：工厂方法模式所创建的对象的超类型
4. 具体产品角色：实现了抽象产品角色所声明的接口

#### 使用java接口或者java抽象类

如果具体工厂角色具有共同的逻辑，那么这些共同的逻辑就可以向上移动到抽象工厂角色中，这也就意味着抽象工厂角色应当用一个java抽象类实现，并由抽象工厂角色提供默认的工厂方法

相反的话，就应该用一个java接口实现

### 抽象工厂模式

抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象

工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构

#### 抽象工厂模式的结构

通过使用抽象工厂模式，可以处理具有相同或者相似等级结构的多个产品族中的产品对象的创建问题

角色：

1. 抽象工厂角色
2. 具体工厂角色
3. 抽象产品角色
4. 具体产品角色

这里和工厂方法模式的不同在于，一个抽象工厂角色可以有多个方法来生成不同的产品

#### 在什么情形下应当使用抽象工厂模式

1. 一个系统不应当依赖产品实例如何被创建，组合和表达的细节，这对于所有心态的工厂模式都是重要的
2. 这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品
3. 同属于一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来
4. 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现

有多少抽象产品就有多少的工厂方法

开闭原则要求一个软件系统可以在不修改原有代码的情况下，通过扩展达到增强其功能的目的，对于一个涉及到多个产品等级结构和多个产品族的系统，其功能增强不外乎两个方面

1. 增加新的产品族
2. 增加新的产品等级结构

### 单例模式

要点有三个：

1. 某个类只能有一个实例
2. 它必须自行创建这个实例
3. 它必须自行向整个系统提供这个实例

饿汉式单例

懒汉式单例

有状态的单例类

无状态的单例类

### 多例模式

特点：

1. 多例类可以有多个实例
2. 多例类必须自己创建，管理自己的实例，并向外界提供自己的实例

今天是11月份的最后一天，马上就要到12月份了，现在这个工作也开始进入收尾阶段，希望不要再加班了，有点难受了

我明天的主要内容就是完成推送的功能

这里可能还要和他们探讨一下关于推送的类型啊，推送的内容等等，做一个更详细的设计

这里也是最让人烦躁的，竟然让一个程序员参与到产品的设计上，可见 有一个专业的产品经理是多么的重要啊

所以我自己的话也要看看张小龙的ppt，看一下别人是怎么设计产品的，不能再这样瞎搞了啊

没办法啊，谁叫我们是一个小公司呢，小公司就是不专业啊 

希望下次可以找一个大一点的公司，而不是小公司了

12月份再见了哦